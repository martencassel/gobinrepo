----------------------------------------------------------------------------------
Immutable files -> cache by path only
Metadata files  -> cache by path + freshness validator (ETag/Last-Modified)
Fallback        -> use digest if headers are missing

Always enable conditionals GETs (If-None-Match, If-Modified-Since) to
minimize bandwidth and improve performance.

----------------------------------------------------------------------------------

Two types of files
1. Immutable package files (.deb, tar.xz etc)
- Once published these never change.
- Cache keys can safely be based on the full URL path (since the filename includes a hash)
2. Mutable metadata files (Packages, Packages.xz, Release, InRelease)
- These changes frequently as new packages are added.
- Cache keys must incorporate freshness validators (ETag/Last-Modified) to avoid
serving stale metadata.

----------------------------------------------------------------------------------

1. Immutable artifacts (packages)
- Use the file path as the cache key.
    debian/pool/main/h/hello/hello_2.10-2_amd64.deb

2. Metadata files (Packages.xz, Release, InRelease):
- Use a composite key:

    {RepoKey}:{Path}:{ETag or Last-Modified}
This ensures that if the upstream repository updates metadata,
your cache will fetch the new version.
debian-remote:debian/dists/stable/main/binary-amd64/Packages.xz:etag=abc123

3. Digest-based fallback:
- If upstream doesn't provide a reliable ETag/Last-Modified headers, compute a digest (SHA256)
  of the file contents and use that as part of the cache key.
- This guarantees uniqueness but requires downloading at least once to compute.
----------------------------------------------------------------------------------


